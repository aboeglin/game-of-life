import type { Set } from "Set"

import { EQ, GT, LT } from "Compare"
import IO from "IO"
import Integer from "Integer"
import List from "List"
import Set from "Set"



alias Vec2 = { x :: Integer, y :: Integer }

export alias Cell = Vec2

instance Comparable { x :: Integer, y :: Integer } {
  compare = (a, b) => a.x > b.x ? GT : a.x < b.x ? LT : a.y > b.y ? GT : a.y < b.y ? LT : EQ
}
// instance (Comparable a,
// Comparable b) => Comparable { x :: a, y :: b } {
//   compare = (a, b) => {
//     xComparison = compare(a.x, b.x)
//     return xComparison == EQ ? compare(a.y, b.y) : xComparison
//   }
// }

export alias Grid = List Vec2

export type Game = Game(Grid, Set Vec2)

type SquareState = Dead | Alive
type SquareInfo = SquareInfo(Vec2, SquareState, Integer)


getGrid :: Game -> Grid
getGrid = where {
  Game(grid, _) =>
    grid
}


getCells :: Game -> Set Vec2
getCells = where {
  Game(_, cells) =>
    cells
}


export make = (w, h) => {
  grid = pipe(
    List.range(0),
    ap(
      pipe(
        List.range(0),
        map((y, x) => ({ x, y })),
      )(h),
    ),
  )(w)

  return Game(grid, Set.empty)
}


neighborPositionsAt :: Vec2 -> List Vec2
neighborPositionsAt = (at) => [
  { x: at.x - 1, y: at.y - 1 },
  { x: at.x, y: at.y - 1 },
  { x: at.x + 1, y: at.y - 1 },
  { x: at.x + 1, y: at.y },
  { x: at.x + 1, y: at.y + 1 },
  { x: at.x, y: at.y + 1 },
  { x: at.x - 1, y: at.y + 1 },
  { x: at.x - 1, y: at.y },
]


isLivingAt :: Set Cell -> Vec2 -> Boolean
isLivingAt = (cells, at) => Set.includes(at, cells)


getSquareInfoAt :: Game -> Vec2 -> SquareInfo
getSquareInfoAt = (game, at) => {
  cells = getCells(game)
  squareState = isLivingAt(cells, at) ? Alive : Dead

  neighborCount = pipe(
    neighborPositionsAt,
    List.filter(isLivingAt(cells)),
    List.length,
  )(at)

  return SquareInfo(at, squareState, neighborCount)
}


computeNextGeneration :: Game -> Set Cell
computeNextGeneration = (game) => pipe(
  getGrid,
  List.reduce(
    (acc, square) => pipe(
      getSquareInfoAt(game),
      where {
        SquareInfo(at, Dead, x) =>
          x == 3 ? Set.insert(at, acc) : acc

        SquareInfo(at, Alive, x) =>
          x == 2 || x == 3 ? Set.insert(at, acc) : acc
      },
    )(square),
    Set.empty,
  ),
)(game)

tick :: Game -> Game
export tick = (game) => {
  grid = getGrid(game)
  nextCells = computeNextGeneration(game)
  return Game(grid, nextCells)
}



// ---- Render --------------------------------------------


moveCursor = (x, y) => `\x1b[${show(y)};${show(x)}H`

printAt :: String -> Integer -> Integer -> {}
printAt = (s, x, y) => IO.put(`${moveCursor(x, y)}${s}`)


FULL_SQUARE = "█"
UPPER_SQUARE = "▀"
LOWER_SQUARE = "▄"

render :: Game -> {}
export render = (game) => {
  pipe(
    getCells,
    map(
      (position) => {
        targetY = Integer.fromFloat(position.y / 2)
        if (position.y % 2 == 0) {
          if (isLivingAt(getCells(game), { x: position.x, y: position.y + 1 })) {
            printAt(FULL_SQUARE, position.x + 1, targetY + 1)
          } else {
            printAt(UPPER_SQUARE, position.x + 1, targetY + 1)
          }
        } else if (!isLivingAt(getCells(game), { x: position.x, y: position.y - 1 })) {
          printAt(LOWER_SQUARE, position.x + 1, targetY + 1)
        }
      },
    ),
  )(game)
}
